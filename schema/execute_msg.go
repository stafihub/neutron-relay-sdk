// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"

// A human readable address.
//
// In Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts
// no assumptions should be made other than being UTF-8 encoded and of reasonable
// length.
//
// This type represents a validated address. It can be created in the following
// ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr =
// deps.api.addr_validate(input)?` 3. Use `let checked: Addr =
// deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must
// only be done from JSON that was validated before such as a contract's state.
// `Addr` must not be used in messages sent by the user because this would result
// in unvalidated instances.
//
// This type is immutable. If you really need to mutate it (Really? Are you sure?),
// create a mutable copy using `let mut mutable = Addr::to_string()` and operate on
// that `String` instance.
type Addr string

type Coin struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount Uint128 `json:"amount" yaml:"amount" mapstructure:"amount"`

	// Denom corresponds to the JSON schema field "denom".
	Denom string `json:"denom" yaml:"denom" mapstructure:"denom"`
}

// A thin wrapper around u128 that is using strings for JSON encoding/decoding,
// such that the full u128 range can be used for clients that convert JSON numbers
// to floats, like JavaScript and jq.
//
// # Examples
//
// Use `from` to create instances of this and `u128` to get the value out:
//
// ``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128);
// assert_eq!(a.u128(), 123);
//
// let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);
//
// let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
type Uint128 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Coin) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in Coin: required")
	}
	if v, ok := raw["denom"]; !ok || v == nil {
		return fmt.Errorf("field denom in Coin: required")
	}
	type Plain Coin
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Coin(plain)
	return nil
}

type ConfigPoolParams struct {
	// EraSeconds corresponds to the JSON schema field "era_seconds".
	EraSeconds *int `json:"era_seconds,omitempty" yaml:"era_seconds,omitempty" mapstructure:"era_seconds,omitempty"`

	// LsmPendingLimit corresponds to the JSON schema field "lsm_pending_limit".
	LsmPendingLimit *int `json:"lsm_pending_limit,omitempty" yaml:"lsm_pending_limit,omitempty" mapstructure:"lsm_pending_limit,omitempty"`

	// LsmSupport corresponds to the JSON schema field "lsm_support".
	LsmSupport *bool `json:"lsm_support,omitempty" yaml:"lsm_support,omitempty" mapstructure:"lsm_support,omitempty"`

	// MinimalStake corresponds to the JSON schema field "minimal_stake".
	MinimalStake interface{} `json:"minimal_stake,omitempty" yaml:"minimal_stake,omitempty" mapstructure:"minimal_stake,omitempty"`

	// NextUnstakeIndex corresponds to the JSON schema field "next_unstake_index".
	NextUnstakeIndex *int `json:"next_unstake_index,omitempty" yaml:"next_unstake_index,omitempty" mapstructure:"next_unstake_index,omitempty"`

	// Offset corresponds to the JSON schema field "offset".
	Offset *int `json:"offset,omitempty" yaml:"offset,omitempty" mapstructure:"offset,omitempty"`

	// Paused corresponds to the JSON schema field "paused".
	Paused *bool `json:"paused,omitempty" yaml:"paused,omitempty" mapstructure:"paused,omitempty"`

	// PoolAddr corresponds to the JSON schema field "pool_addr".
	PoolAddr string `json:"pool_addr" yaml:"pool_addr" mapstructure:"pool_addr"`

	// ProtocolFeeCommission corresponds to the JSON schema field
	// "protocol_fee_commission".
	ProtocolFeeCommission interface{} `json:"protocol_fee_commission,omitempty" yaml:"protocol_fee_commission,omitempty" mapstructure:"protocol_fee_commission,omitempty"`

	// ProtocolFeeReceiver corresponds to the JSON schema field
	// "protocol_fee_receiver".
	ProtocolFeeReceiver *string `json:"protocol_fee_receiver,omitempty" yaml:"protocol_fee_receiver,omitempty" mapstructure:"protocol_fee_receiver,omitempty"`

	// RateChangeLimit corresponds to the JSON schema field "rate_change_limit".
	RateChangeLimit interface{} `json:"rate_change_limit,omitempty" yaml:"rate_change_limit,omitempty" mapstructure:"rate_change_limit,omitempty"`

	// UnbondCommission corresponds to the JSON schema field "unbond_commission".
	UnbondCommission interface{} `json:"unbond_commission,omitempty" yaml:"unbond_commission,omitempty" mapstructure:"unbond_commission,omitempty"`

	// UnbondingPeriod corresponds to the JSON schema field "unbonding_period".
	UnbondingPeriod *int `json:"unbonding_period,omitempty" yaml:"unbonding_period,omitempty" mapstructure:"unbonding_period,omitempty"`

	// UnstakeTimesLimit corresponds to the JSON schema field "unstake_times_limit".
	UnstakeTimesLimit *int `json:"unstake_times_limit,omitempty" yaml:"unstake_times_limit,omitempty" mapstructure:"unstake_times_limit,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigPoolParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pool_addr"]; !ok || v == nil {
		return fmt.Errorf("field pool_addr in ConfigPoolParams: required")
	}
	type Plain ConfigPoolParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConfigPoolParams(plain)
	return nil
}

type InitPoolParams struct {
	// Active corresponds to the JSON schema field "active".
	Active Uint128 `json:"active" yaml:"active" mapstructure:"active"`

	// Bond corresponds to the JSON schema field "bond".
	Bond Uint128 `json:"bond" yaml:"bond" mapstructure:"bond"`

	// ChannelIdOfIbcDenom corresponds to the JSON schema field
	// "channel_id_of_ibc_denom".
	ChannelIdOfIbcDenom string `json:"channel_id_of_ibc_denom" yaml:"channel_id_of_ibc_denom" mapstructure:"channel_id_of_ibc_denom"`

	// Era corresponds to the JSON schema field "era".
	Era int `json:"era" yaml:"era" mapstructure:"era"`

	// IbcDenom corresponds to the JSON schema field "ibc_denom".
	IbcDenom string `json:"ibc_denom" yaml:"ibc_denom" mapstructure:"ibc_denom"`

	// InterchainAccountId corresponds to the JSON schema field
	// "interchain_account_id".
	InterchainAccountId string `json:"interchain_account_id" yaml:"interchain_account_id" mapstructure:"interchain_account_id"`

	// LsdToken corresponds to the JSON schema field "lsd_token".
	LsdToken string `json:"lsd_token" yaml:"lsd_token" mapstructure:"lsd_token"`

	// PendingShareTokens corresponds to the JSON schema field "pending_share_tokens".
	PendingShareTokens []Coin `json:"pending_share_tokens" yaml:"pending_share_tokens" mapstructure:"pending_share_tokens"`

	// ProtocolFeeReceiver corresponds to the JSON schema field
	// "protocol_fee_receiver".
	ProtocolFeeReceiver string `json:"protocol_fee_receiver" yaml:"protocol_fee_receiver" mapstructure:"protocol_fee_receiver"`

	// Rate corresponds to the JSON schema field "rate".
	Rate Uint128 `json:"rate" yaml:"rate" mapstructure:"rate"`

	// RemoteDenom corresponds to the JSON schema field "remote_denom".
	RemoteDenom string `json:"remote_denom" yaml:"remote_denom" mapstructure:"remote_denom"`

	// Unbond corresponds to the JSON schema field "unbond".
	Unbond Uint128 `json:"unbond" yaml:"unbond" mapstructure:"unbond"`

	// ValidatorAddrs corresponds to the JSON schema field "validator_addrs".
	ValidatorAddrs []string `json:"validator_addrs" yaml:"validator_addrs" mapstructure:"validator_addrs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitPoolParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["active"]; !ok || v == nil {
		return fmt.Errorf("field active in InitPoolParams: required")
	}
	if v, ok := raw["bond"]; !ok || v == nil {
		return fmt.Errorf("field bond in InitPoolParams: required")
	}
	if v, ok := raw["channel_id_of_ibc_denom"]; !ok || v == nil {
		return fmt.Errorf("field channel_id_of_ibc_denom in InitPoolParams: required")
	}
	if v, ok := raw["era"]; !ok || v == nil {
		return fmt.Errorf("field era in InitPoolParams: required")
	}
	if v, ok := raw["ibc_denom"]; !ok || v == nil {
		return fmt.Errorf("field ibc_denom in InitPoolParams: required")
	}
	if v, ok := raw["interchain_account_id"]; !ok || v == nil {
		return fmt.Errorf("field interchain_account_id in InitPoolParams: required")
	}
	if v, ok := raw["lsd_token"]; !ok || v == nil {
		return fmt.Errorf("field lsd_token in InitPoolParams: required")
	}
	if v, ok := raw["pending_share_tokens"]; !ok || v == nil {
		return fmt.Errorf("field pending_share_tokens in InitPoolParams: required")
	}
	if v, ok := raw["protocol_fee_receiver"]; !ok || v == nil {
		return fmt.Errorf("field protocol_fee_receiver in InitPoolParams: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate in InitPoolParams: required")
	}
	if v, ok := raw["remote_denom"]; !ok || v == nil {
		return fmt.Errorf("field remote_denom in InitPoolParams: required")
	}
	if v, ok := raw["unbond"]; !ok || v == nil {
		return fmt.Errorf("field unbond in InitPoolParams: required")
	}
	if v, ok := raw["validator_addrs"]; !ok || v == nil {
		return fmt.Errorf("field validator_addrs in InitPoolParams: required")
	}
	type Plain InitPoolParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InitPoolParams(plain)
	return nil
}
